Что делает команда - go mod init bot-flat-matcher

Команда
go mod init bot-flat-matcher
делает следующее:

Создаёт файл go.mod в корне вашего проекта.

Задаёт имя модуля — в данном случае bot-flat-matcher. Это будет «корневой путь» для всех ваших пакетов.

Включает поддержку модулей Go (Go Modules), то есть вы сможете управлять зависимостями (внешними библиотеками) через команды go get, go build и т. д.

После выполнения рядом с кодом появится файл go.mod, примерно такого содержания:

module bot-flat-matcher

go 1.20
Строка module bot-flat-matcher — базовый путь ваших пакетов.

go 1.20 — версия Go, под которой вы разрабатываете (берётся из вашей установленной версии Go).

Зачем это нужно?

Управление зависимостями. Позволяет объявлять, обновлять и фиксировать версии библиотек без GOPATH.

Изоляция проекта. Каждый модуль имеет свой собственный набор версий пакетов.

Совместимость. С Go Modules проще работать в CI/CD и между разными машинами, поскольку весь список зависимостей хранится в go.mod и go.sum.

Простая аналогия для «чайников»:
Представьте, что ваш проект ― это книга рецептов. go.mod — это оглавление и список покупок ингредиентов с точными версиями (например, «сахар 1.0.3», «мука 2.1.0»). Когда кто-то другой хочет «приготовить» ваш проект, он открывает оглавление и сразу понимает, какие «ингредиенты» (библиотеки) и в каких версиях нужны.


На скриншоте вы видите базовую структуру проекта в соответствии с рекомендациями TЗ:

pgsql
Копировать
cmd/
  bot/
internal/
  bot/
  db/
  domain/
  service/
  scheduler/   ← (не показан на скриншоте, но рекомендован)
pkg/
Разберём каждый из этих каталогов:

1. cmd/bot
Что здесь лежит: точка входа вашего приложения — фактически файл main.go.

Зачем нужен:

Запускает бот: читает переменные окружения (BOT_TOKEN, DATABASE_URL), инициализирует все зависимости.

Подключает обработчики команд и запускает цикл чтения апдейтов от Telegram.

Пример cmd/bot/main.go:

go
Копировать
package main

import (
    "log"
    "os"
    "bot-flat-matcher/internal/bot"
    "bot-flat-matcher/internal/db"
)

func main() {
    token := os.Getenv("BOT_TOKEN")
    botAPI, err := bot.NewTelegramBot(token)
    if err != nil {
        log.Fatal(err)
    }

    database, err := db.Connect(os.Getenv("DATABASE_URL"))
    if err != nil {
        log.Fatal(err)
    }

    bot.Run(botAPI, database)
}
2. internal/bot
Что здесь лежит: всё, что связано непосредственно с Telegram-API:

Инициализация клиента (tgbotapi.NewBotAPI)

Разбор входящих апдейтов (Update), маршрутизация команд (/start, /browse_listings и т. д.)

Формирование и отправка сообщений, inline-кнопок, клавиатур.

Зачем: отделить «оболочку» Telegram от бизнес-логики — чтобы, например, в будущем можно было заменить мессенджер, не трогая остальной код.

3. internal/db
Что здесь лежит: всё, что связано с базой данных:

Коннектор (sqlx или ORM-клиент)

Модели User, Listing, SeekerLike и т. д.

Методы CRUD: CreateUser, GetListings, SaveLike и т. п.

Миграции (можно держать в подпапке migrations/).

Зачем: централизовать доступ к данным, чтобы не дублировать SQL-код в разных местах и легко было писать unit-тесты, мокая этот слой.

4. internal/domain
Что здесь лежит: чистые доменные сущности и правила, независимые от Telegram и БД:

Структуры: type SeekerProfile struct { … }, type OwnerProfile struct { … }

Интерфейсы (abstractions): type ListingRepository interface { … }, type NotificationService interface { … }

Бизнес-логика: функции матчинга (func Match(seekerLikes, ownerLikes []Like) []Match) и валидации данных (например, проверка диапазона цены).

Зачем: гарантировать, что правила вашей предметной области (real estate matching) лаконично описаны и легко тестируются, без «шумящих» зависимостей.

5. (Рекомендовано) internal/service и internal/scheduler
service: вспомогательные сервисы — например, работа с файлами (загрузка/хранение фото в S3), отправка e-mail или push-уведомлений.

scheduler: фоновая логика по крону — напоминания, чистка старых объявлений, повторные нотификации.

6. pkg
Что здесь лежит: утилиты и библиотеки, которые могут быть переиспользованы в других проектах (например, обёртка для логирования, кастомный middleware для HTTP-сервиса и т. д.).

Почему отдельно: потому что содержимое internal/ строго приватно для этого модуля, а pkg/ — публично.

Итог: такая структура помогает чётко разделить ответственность:

cmd/ — запуск и сборка приложения;

internal/bot — интерфейс с пользователем (Telegram);

internal/db — слой доступа к данным;

internal/domain — «чистая» бизнес-логика;

pkg/ — переиспользуемый код.

Это делает проект более поддерживаемым, облегчает тестирование и будущие расширения.

